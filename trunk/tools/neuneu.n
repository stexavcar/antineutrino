internal def is_whitespace();
internal def is_alpha();
internal def is_digit();

def is_ident_start() -> is_alpha() or (this = "_");
def is_ident_part() -> is_ident_start() or is_digit();


(* --- T o k e n s --- *)


protocol Token {
  def is_identifier() -> false;
  def is_keyword(name) -> false;
  def is_delimiter(name) -> false;
}


protocol Identifier : Token {
  
  def to_string() -> "#<identifier '${this.value}'>";

  def is_value() -> true;
  
  static def make(value) -> new Identifier() { value: value };
  
}


protocol Keyword : Token {
  
  def to_string() -> "#<keyword ${this.name}>";
  
  def is_term(name) -> (name = this.name);
  
  static def make(name) -> new Keyword() { name: name };
  
}


protocol Delimiter : Token {
  
  def to_string() -> "#<delimiter ${this.name}>";
  
  def is_term(name) -> this.name = name;
  
  static def make(name) -> new Delimiter() { name: name };
  
}


(* ---K e y w o r d s --- *)


def keywords := ["def"];


def delimiters := ["(", ")", "{", "}", "[", "]"];


(* --- S c a n n e r --- *)


protocol Scanner {
  
  def has_more() -> (this.pos < |this.input|);
  
  def current -> this.input[this.pos];
  
  def advance() -> (this.pos := this.pos + 1);
  
  def substring(range) -> this.input.substring(range);
  
  def skip_whitespace() {
    while (this.has_more() and this.current·is_whitespace())
      this.advance();
  }
  
  def next_token() {
    var result := null;
    if (not this.has_more()) return null;
    if (this.current·is_ident_start()) {
      result := this.scan_identifier();
    } else if (delimiters ∋ this.current) {
      result := this.scan_delimiter();
    } else {
      def char := this.current;
      raise unexpected_character(char);
    }
    this.skip_whitespace();
    return result;
  }
  
  def scan_delimiter() {
    var value := "";
    while (this.has_more()) {
      def prev_value := value;
      value := value + this.current;
      if (not delimiters ∋ value)
        return Delimiter.make(prev_value);
      else
        this.advance();
    }
    // At this point we must have looped at least once and, since we
    // looped again, the delimiters list must contain the value.
    return Delimiter.make(value);
  }
  
  def scan_identifier() {
    def start := this.pos;
    while (this.current·is_ident_part())
      this.advance();
    def end := this.pos;
    def value := this.substring(start..end);
    if (keywords ∋ value) return Keyword.make(value);
    else return Identifier.make(value);
  }
  
  # Factory methods for creating scanners processing the specified
  # input
  static def make(input) {
    def scan := new Scanner() {
      input: input,
      pos: 0
    };
    scan.skip_whitespace();
    return scan;
  }
  
}


(* --- G r a m m a r --- *)

protocol Grammar {

  def parse(start_name, tokens) {
    def state := ParserState.make(tokens, 0);
    def start := this.get_nonterm(start_name);
    return start.parse(state);
  }
  
  def get_nonterm(name) -> this.nonterms[name];

  static def make(nonterms) -> new Grammar() { nonterms: nonterms };
  
}

protocol ParserState {

  static def make(tokens, pos) -> new ParserState() {
    tokens: tokens,
    pos: pos
  };
  
  def current() -> this.tokens[this.pos];
  
  def advance() -> this.pos := this.pos + 1;

}

protocol Term {

  def to_string() -> this.value;
  
  def parse(state) {
    if (not state.current().is_term(this.value))
      return false;
    state.advance();
    return this.value;
  }
  
}

protocol Value {

  def to_string() -> "%";
  
  def parse(state) {
    if (not state.current().is_value())
      return false;
    def value := state.current().value;
    state.advance();
    return value;
  }
  
}

protocol Sequence {

  def to_string() {
    var result := "";
    var i := 0;
    while (i < |this.elms|) {
      if (not i = 0) result := result + " ";
      result := result + this.elms[i].to_string();
      i := i + 1;
    }
    return result;
  }
  
  def parse(state) {
    var i := 0;
    def values := new List();
    while (i < |this.elms|) {
      def value := this.elms[i].parse(state);
      if (value = false) return false;
      values.add(value);
      i := i + 1;
    }
    return values;
  }

}

protocol Repeat {

}

protocol Nonterm {

}

def term(value) -> new Term() { value: value };

def value() -> new Value();

def delim(value) -> new Delim() { value: value };

def seq(elms) -> new Sequence() { elms: elms };

def star(value) -> new Repeat() { value: value };

def nonterm(name) -> new Nonterm() { name: name };

(* --- M a i n --- *)


def get_grammar() {
  def nonterms := new Map();
  nonterms["toplevel"] := seq([term("def"), value(), term("("), term(")"), term("{"), term("}")]);
  nonterms["program"] := star(nonterm("toplevel"));
  return Grammar.make(nonterms);
}


def main() {
  def gram := get_grammar();
  def input := "def main() { } def main2() { }";
  def scan := Scanner.make(input);
  def tokens := new List();
  while (scan.has_more())
    tokens.add(scan.next_token());
  print(gram.parse("toplevel", tokens));
}
