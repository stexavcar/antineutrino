/**
 * A Mach-O file.  Use the add_*_command functions to add load commands,
 * and methods on the segment_commands to add segments and sections.
 * 
 * See http://developer.apple.com/documentation/DeveloperTools/
 * Conceptual/MachORuntime/index.html for the full specification.
 *
protocol MachO;

/**
 * Create a new Mach-O with the given properties.  Load commands and
 * sections are added after construction.
 *
def MachO.new(cputype, cpusubtype, filetype, flags) -> new MachO {
  cputype := cputype,
  cpusubtype := cpusubtype,
  filetype := filetype,
  commands := new ArrayList(0),
  flags := flags
};

/**
 * Returns the total size of the load commands contained in this
 * binary.
 *
def (this: MachO).cmdsize {
  ref result := 0;
  for (def command : this.commands)
    result := result + command.cmdsize;
  result;
}

protocol MachOStruct;

def MachOStruct.new() -> new MachOStruct {
  load_commands := new ArrayList(0),
  sections := new ArrayList(0)
};

def (this: MachO).write_binary(out) {
  this.write_header(out);
  this.write_load_commands(out);
  this.write_segments(out);
}

/**
 * Write this binary to the given binary stream.
 * 
 * struct mach_header {
 *   uint32_t magic;
 *   cpu_type_t cputype;
 *   cpu_subtype_t cpusubtype;
 *   uint32_t filetype;
 *   uint32_t ncmds;
 *   uint32_t sizeofcmds;
 *   uint32_t flags;
 * };
 *
def (this: MachO).write_header(out) {
  out.write_int32(16rFEEDFACE);
  out.write_int32(this.cputype);
  out.write_int32(this.cpusubtype);
  out.write_int32(this.filetype);
  out.write_int32(this.commands.length);
  out.write_int32(this.cmdsize);
  out.write_int32(this.flags);
}

def (this: MachO).header_size -> 28;

def align(value, factor) {
  if (value % factor) = 0 then
    value
  else
    value + (factor - (value % factor));
}

def page_size_ceil(size) -> align(size, PAGE_SIZE);

def (this: MachO).write_load_commands(out) {
  ref fileoff := page_size_ceil(this.cmdsize + this.header_size);
  for (def command : this.commands) {
    command.write_load_command(out, fileoff);
    fileoff := page_size_ceil(fileoff + command.filesize);
  }
}

def (this: MachO).write_segments(out) {
  ref fileoff := page_size_ceil(this.cmdsize + this.header_size);
  out.pad_to(fileoff);
  for (def command : this.commands) {
    for (def segment : command.segments) {
      segment.write_sections(out, fileoff);
      fileoff := page_size_ceil(fileoff + command.filesize);
      out.pad_to(fileoff);
    }
  }
}

def (this: MachO).segments -> fn for (fun) {
  for (def command : this.commands)
    command.segments.for(fun)
};

/**
 * Return a binary blob containing the encoded contents of this Mach-O.
 *
def (this: MachO).to_blob {
  def out := new BlobStream;
  this.write_binary(out);
  out.get_blob();
}

/**
 * Returns a new segment_command contained in this Mach-O.
 *
def (this: MachO).add_segment_command(segname) {
  def result := new SegmentCommand {
    segname := segname,
    sections := new ArrayList(0)
  };
  this.commands.add(result);
  result;
}

def (this: MachO).add_symtab_command {
  def result := new SymtabCommand {
    
  };
  this.commands.add(result);
  result;
}

protocol LoadCommand;

def (this: LoadCommand).segments -> fn for (fun) -> null;

/**
 * A load command corresponding to a segment.
 *
protocol SegmentCommand;
def SegmentCommand is LoadCommand;

/*
 * struct segment_command {
 *   uint32_t cmd;
 *   uint32_t cmdsize;
 *   char segname[16];
 *   uint32_t vmaddr;
 *   uint32_t vmsize;
 *   uint32_t fileoff;
 *   uint32_t filesize;
 *   vm_prot_t maxprot;
 *   vm_prot_t initprot;
 *   uint32_t nsects;
 *   uint32_t flags;
 * };
 *
def (this: SegmentCommand).write_load_command(out, fileoff) {
  out.write_int32(LC_SEGMENT);
  out.write_int32(this.cmdsize);
  out.write_c_string(this.segname, 16);
  out.write_int32(fileoff);
  def filesize := this.filesize;
  out.write_int32(filesize);
  out.write_int32(fileoff);
  out.write_int32(filesize);
  out.write_int32(7); // maxprot
  out.write_int32(5); // initprot
  out.write_int32(this.sections.length);
  out.write_int32(0); // flags
  this.write_section_headers(out, fileoff);
}

def (this: SegmentCommand).segments -> fn for (fun) -> fun(this);

def (this: SegmentCommand).filesize -> 1;

def (this: SegmentCommand).cmdsize -> 56 + (this.sections.length * Section.size);

def (this: SegmentCommand).write_sections(out, fileoff) {
  for (def section : this.sections)
    section.write_contents(out);
}

def (this: SegmentCommand).write_section_headers(out, fileoff) {
  ref off := fileoff;
  for (def section : this.sections) {
    section.write_header(out, off);
    off := off + section.filesize;
  }
}

def (this: SegmentCommand).add_section(sectname, contents) {
  def result := new Section {
    parent := this,
    sectname := sectname,
    contents := contents
  };
  this.sections.add(result);
  result;
}

protocol SymtabCommand;

protocol Section;

def Section.size -> 68;

/*
 * struct section {
 *   char sectname[16];
 *   char segname[16];
 *   uint32_t addr;
 *   uint32_t size;
 *   uint32_t offset;
 *   uint32_t align;
 *   uint32_t reloff;
 *   uint32_t nreloc;
 *   uint32_t flags;
 *   uint32_t reserved1;
 *   uint32_t reserved2;
 * };
 *
def (this: Section).write_header(out, fileoff) {
  out.write_c_string(this.sectname, 16);
  out.write_c_string(this.parent.segname, 16);
  out.write_int32(fileoff);
  out.write_int32(this.filesize);
  out.write_int32(fileoff);
  out.write_int32(2);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(16r80000400);
  out.write_int32(0);
  out.write_int32(0);
}

def (this: Section).write_contents(out) {
  print(out);
  out.write_data(this.contents, 0, this.contents.length);
}

def (this: Section).filesize -> this.contents.length;

*/