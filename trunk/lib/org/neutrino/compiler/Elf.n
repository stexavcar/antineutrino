protocol ElfFormat;

def ElfFormat.new() -> new ElfFormat { };

def (this is ElfFormat).builder(binary) -> new Elf(binary);

protocol Elf;

def Elf.new(binary) {
  def null_section := new ElfNullSection();
  def string_table := new ElfStringTable();
  def result := new Elf {
    binary := binary,
    layout := new Layouter(),
    string_table := string_table,
    sections := new ArrayList [ null_section, string_table ]
  }
  result;
}

def (this is Elf).calculate_layout() {
  def layout := this.layout;
  // Add the elf header as the root element
  def header_name := Elf.header_name;
  layout.add_section(header_name, null, Elf.header_size, 1);
  // Add the actual sections
  for (section : this.sections) {
    def name := section.name;
    layout.next_section(name, section.size, section.alignment);
  }
  // Add the section headers
  layout.next_section(Elf.section_header_start_name, 0, WORD_SIZE);
  for (section : this.sections) {
    def name := section.header_name;
    layout.next_section(name, ElfSection.header_size, WORD_SIZE);
  }
  layout.calculate();
}

def (this is Elf).section_index(section) {
  with_1cc (return) {
    for (i : 0 .. this.sections.length) {
      if this.sections[i] = section
        then return(i);
    }
    null;
  }
}

def (this is Elf).add_code_block(name, code) { }

def (this is Elf).finalize() {
  for (section : this.sections)
    section.finalize(this);
  this.calculate_layout();
  this.layout.dump();
}

def (this is Elf).encode(out) {
  this.encode_header(out);
  this.encode_sections(out);
  this.encode_section_headers(out);
}

/*
 * typedef struct Elf32_Ehdr {
 *   unsigned char e_ident[EI_NIDENT];
 *   Elf32_Half e_type;
 *   Elf32_Half e_machine;
 *   Elf32_Word e_version;
 *   Elf32_Addr e_entry;
 *   Elf32_Off e_phoff;
 *   Elf32_Off e_shoff;
 *   Elf32_Word e_flags;
 *   Elf32_Half e_ehsize;
 *   Elf32_Half e_phentsize;
 *   Elf32_Half e_phnum;
 *   Elf32_Half e_shentsize;
 *   Elf32_Half e_shnum;
 *   Elf32_Half e_shstrndx;
 * }
 */
def (this is Elf).encode_header(out) {
  def info := this.layout.info(Elf.header_name);
  this.encode_identification(out);
  out.write_int16(1); // ET_REL
  out.write_int16(3); // EM_386
  out.write_int32(1); // EV_CURRENT
  out.write_int32(0); // No entry point
  out.write_int32(0); // No header table
  def shdr_info := this.layout.info(Elf.section_header_start_name);
  out.write_int32(shdr_info.start); // Section header offset
  out.write_int32(0); // No flags
  out.write_int16(info.size); // Size of this header
  out.write_int16(0); // Size of program headers
  out.write_int16(0); // Number of program headers
  out.write_int16(ElfSection.header_size); // Size of section headers
  def nsect := this.sections.length;
  out.write_int16(nsect); // Number of section headers
  def strndx := this.section_index(this.string_table);
  out.write_int16(strndx); // Section header string table index
  assert_equal(info.end, out.length);
}

def (this is Elf).encode_identification(out) {
  out.write_int32(16r464C457F); // MAGIC
  out.write_int8(1); // ELFCLASS32
  out.write_int8(1); // ELFDATA2LSB
  out.write_int8(1); // VERSION
  out.pad_to(16);
}

def (this is Elf).encode_section_headers(out) {
  def start_info := this.layout.info(Elf.section_header_start_name);
  out.pad_to(start_info.start);
  for (section : this.sections) {
    def info := this.layout.info(section.header_name);
    assert_equal(info.start, out.length);
    this.encode_section_header(out, section);
    assert_equal(info.end, out.length);
  }
}

def (this is Elf).encode_sections(out) {
  for (section : this.sections) {
    def info := this.layout.info(section.name);
    assert_true(out.length <= info.start);
    out.pad_to(info.start);
    section.encode(out, this);
    assert_true(out.length <= info.end);
    out.pad_to(info.end);
  }
}

def Elf.header_size -> 13 * WORD_SIZE;

def Elf.header_name -> "Elf32_Ehdr";

def Elf.section_header_start_name -> "Elf32_Shdr.start";

/*
 * typedef struct Elf32_Shdr {
 *   Elf32_Word sh_name;
 *   Elf32_Word sh_type;
 *   Elf32_Word sh_flags;
 *   Elf32_Addr sh_addr;
 *   Elf32_Off sh_offset;
 *   Elf32_Word sh_size;
 *   Elf32_Word sh_link;
 *   Elf32_Word sh_info;
 *   Elf32_Word sh_addralign;
 *   Elf32_Word sh_entsize;
 * }
 */
def (this is Elf).encode_section_header(out, section) {
  def name := section.name;
  def info := this.layout.info(name);
  def header_info := this.layout.info(section.header_name);
  assert_equal(header_info.start, out.length);
  out.write_int32(this.string_table[name]);
  out.write_int32(section.type);
  out.write_int32(0); // flags
  out.write_int32(0); // addr
  out.write_int32(info.start); // offset
  out.write_int32(info.size); // size
  out.write_int32(0); // link
  out.write_int32(0); // info
  out.write_int32(section.alignment); // align
  out.write_int32(0); // entsize
  assert_equal(header_info.end, out.length);
}

protocol ElfSection;

def (this is ElfSection).header_name -> "${this.name}.header";

def (this is ElfSection).finalize(elf) {
  elf.string_table.ensure(this.name);
}

def ElfSection.header_size -> 10 * WORD_SIZE;

protocol ElfStringTable is ElfSection;

def ElfStringTable.new() {
  def result := new ElfStringTable {
    table := new HashMap(),
    strings := new ArrayList(),
    r_size := new Ref(0)
  };
  result.ensure("");
  result;
}

def (this is ElfStringTable).alignment -> 1;

def (this is ElfStringTable).size -> this.r_size.get();

def (this is ElfStringTable).name -> ".strtab";

def (this is ElfStringTable).type -> 3; // SHT_STRTAB

def (this is ElfStringTable)[key]
 -> this.table[key];

def (this is ElfStringTable).ensure(key) {
  def prev := this.table[key];
  if prev = null then {
    def index := this.size;
    this.table[key] := index;
    this.r_size.set(index + key.length + 1);
    this.strings.add(key);
    index;
  } else {
    prev;
  }
}

def (this is ElfStringTable).encode(out, elf) {
  def info := elf.layout.info(this.name);
  assert_equal(info.start, out.length);
  for (str : this.strings)
    out.write_c_string(str);
  assert_equal(info.end, out.length);
}

protocol ElfNullSection is ElfSection;

def ElfNullSection.new() -> new ElfNullSection { };

def (this is ElfNullSection).name -> "";

def (this is ElfNullSection).size -> 0;

def (this is ElfNullSection).type -> 0; // SHT_NULL

def (this is ElfNullSection).alignment -> 0;

def (this is ElfNullSection).encode(out, elf);
