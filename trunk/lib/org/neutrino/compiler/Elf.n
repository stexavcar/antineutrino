/**
 * Implementation of objects in the ELF format (Executable and
 * Linkable Format)
 * 
 * See the full specification in the System V Application Binary
 * Interface, http://www.sco.com/developers/devspecs/gabi41.pdf.
 */

protocol ElfFormat;

def ElfFormat.new() -> new ElfFormat { };

def (this is ElfFormat).builder(binary) -> new Elf(binary);

protocol Elf;

def Elf.new(binary) {
  def null_section := new ElfNullSection();
  def text := new ElfTextSection();
  def strtab := new ElfStringTable();
  def symtab := new ElfSymbolTable(strtab);
  def result := new Elf {
    binary := binary,
    layout := new Layouter(),
    strtab := strtab,
    text := text,
    symtab := symtab,
    sections := new ArrayList [ null_section, text, symtab, strtab ]
  }
  result;
}

def (this is Elf).calculate_layout() {
  def layout := this.layout;
  // Add the elf header as the root element
  def header_name := Elf.header_name;
  layout.add_section(header_name, null, Elf.header_size, 1);
  // Add the actual sections
  for (section : this.sections) {
    def name := section.name;
    layout.next_section(name, section.size, section.alignment);
  }
  // Add the section headers
  layout.next_section(Elf.section_header_start_name, 0, WORD_SIZE);
  for (section : this.sections) {
    def name := section.header_name;
    layout.next_section(name, ElfSection.header_size, WORD_SIZE);
  }
  layout.calculate();
}

def (this is Elf).section_index(section) {
  with_1cc (return) {
    for (i : 0 .. this.sections.length) {
      if this.sections[i] = section
        then return(i);
    }
    null;
  }
}

def (this is Elf).add_code_block(name, code) {
  def offset := this.text.add_code(code);
  this.symtab.add_local_entry(name, offset, code.length);
}

def (this is Elf).finalize() {
  for (section : this.sections)
    section.finalize(this);
  this.calculate_layout();
  this.layout.dump();
}

def (this is Elf).encode(out) {
  this.encode_header(out);
  this.encode_sections(out);
  this.encode_section_headers(out);
}

/*
 * typedef struct Elf32_Ehdr {
 *   unsigned char e_ident[EI_NIDENT];
 *   Elf32_Half e_type;
 *   Elf32_Half e_machine;
 *   Elf32_Word e_version;
 *   Elf32_Addr e_entry;
 *   Elf32_Off e_phoff;
 *   Elf32_Off e_shoff;
 *   Elf32_Word e_flags;
 *   Elf32_Half e_ehsize;
 *   Elf32_Half e_phentsize;
 *   Elf32_Half e_phnum;
 *   Elf32_Half e_shentsize;
 *   Elf32_Half e_shnum;
 *   Elf32_Half e_shstrndx;
 * }
 */
def (this is Elf).encode_header(out) {
  def info := this.layout.info(Elf.header_name);
  this.encode_identification(out);
  out.write_int16(1); // ET_REL
  out.write_int16(3); // EM_386
  out.write_int32(1); // EV_CURRENT
  out.write_int32(0); // No entry point
  out.write_int32(0); // No header table
  def shdr_info := this.layout.info(Elf.section_header_start_name);
  out.write_int32(shdr_info.start); // Section header offset
  out.write_int32(0); // No flags
  out.write_int16(info.size); // Size of this header
  out.write_int16(0); // Size of program headers
  out.write_int16(0); // Number of program headers
  out.write_int16(ElfSection.header_size); // Size of section headers
  def nsect := this.sections.length;
  out.write_int16(nsect); // Number of section headers
  def strndx := this.section_index(this.strtab);
  out.write_int16(strndx); // Section header string table index
  assert_equal(info.end, out.length);
}

def (this is Elf).encode_identification(out) {
  out.write_int32(16r464C457F); // MAGIC
  out.write_int8(1); // ELFCLASS32
  out.write_int8(1); // ELFDATA2LSB
  out.write_int8(1); // VERSION
  out.pad_to(16);
}

def (this is Elf).encode_section_headers(out) {
  def start_info := this.layout.info(Elf.section_header_start_name);
  out.pad_to(start_info.start);
  for (section : this.sections) {
    def info := this.layout.info(section.header_name);
    assert_equal(info.start, out.length);
    this.encode_section_header(out, section);
    assert_equal(info.end, out.length);
  }
}

def (this is Elf).encode_sections(out) {
  for (section : this.sections) {
    def info := this.layout.info(section.name);
    assert_true(out.length <= info.start);
    out.pad_to(info.start);
    section.encode(out, this);
    assert_true(out.length <= info.end);
    out.pad_to(info.end);
  }
}

def Elf.header_size -> 13 * WORD_SIZE;

def Elf.header_name -> "Elf32_Ehdr";

def Elf.section_header_start_name -> "Elf32_Shdr.start";

/*
 * typedef struct Elf32_Shdr {
 *   Elf32_Word sh_name;
 *   Elf32_Word sh_type;
 *   Elf32_Word sh_flags;
 *   Elf32_Addr sh_addr;
 *   Elf32_Off sh_offset;
 *   Elf32_Word sh_size;
 *   Elf32_Word sh_link;
 *   Elf32_Word sh_info;
 *   Elf32_Word sh_addralign;
 *   Elf32_Word sh_entsize;
 * }
 */
def (this is Elf).encode_section_header(out, section) {
  def name := section.name;
  def info := this.layout.info(name);
  def header_info := this.layout.info(section.header_name);
  assert_equal(header_info.start, out.length);
  out.write_int32(this.strtab[name]);
  out.write_int32(section.type);
  out.write_int32(0); // flags
  out.write_int32(0); // addr
  out.write_int32(info.start);
  out.write_int32(info.size);
  out.write_int32(section.link(this)); // link
  out.write_int32(section.info);
  out.write_int32(section.alignment);
  out.write_int32(section.entry_size);
  assert_equal(header_info.end, out.length);
}

protocol ElfSection;

def (this is ElfSection).header_name -> "${this.name}.header";

def (this is ElfSection).finalize(elf) {
  elf.strtab.ensure(this.name);
}

def ElfSection.header_size -> 10 * WORD_SIZE;

def (this is ElfSection).entry_size -> 0;

def (this is ElfSection).info -> 0;

def (this is ElfSection).link(elf) -> 0;

/**
 * The string table (ABI 4-21).  This is simply a sequence of
 * null-terminated C strings that is indexed by the byte offset of the
 * first character of the string you're interested in.
 */
protocol ElfStringTable is ElfSection;

def ElfStringTable.new() {
  def result := new ElfStringTable {
    table := new HashMap(),
    strings := new ArrayList(),
    r_size := new Ref(0)
  };
  result.ensure("");
  result;
}

def (this is ElfStringTable).alignment -> 1;

def (this is ElfStringTable).size -> this.r_size.get();

def (this is ElfStringTable).name -> ".strtab";

def (this is ElfStringTable).type -> 3; // SHT_STRTAB

def (this is ElfStringTable)[key]
 -> this.table[key];

def (this is ElfStringTable).ensure(key) {
  def prev := this.table[key];
  if prev = null then {
    def index := this.size;
    this.table[key] := index;
    this.r_size.set(index + key.length + 1);
    this.strings.add(key);
    index;
  } else {
    prev;
  }
}

def (this is ElfStringTable).encode(out, elf) {
  def info := elf.layout.info(this.name);
  assert_equal(info.start, out.length);
  for (str : this.strings)
    out.write_c_string(str);
  assert_equal(info.end, out.length);
}

/**
 * This "section" is purely a header, it has no actual section data.
 * It is used as a marker of some sort -- stuff doesn't work without
 * it.
 */
protocol ElfNullSection is ElfSection;

def ElfNullSection.new() -> new ElfNullSection { };

def (this is ElfNullSection).name -> "";

def (this is ElfNullSection).size -> 0;

def (this is ElfNullSection).type -> 0; // SHT_NULL

def (this is ElfNullSection).alignment -> 0;

def (this is ElfNullSection).encode(out, elf);

/**
 * Text section, containing executable code.  This is just a flat byte
 * array, the structure is derived from the symtab.
 */
protocol ElfTextSection is ElfSection;

def ElfTextSection.new() -> new ElfTextSection {
  data := new BlobStream()
}

def (this is ElfTextSection).add_code(code) {
  def offset := this.data.length;
  this.data.write_data(code);
  offset;
}

def (this is ElfTextSection).name -> ".text";

def (this is ElfTextSection).size -> this.data.length;

def (this is ElfTextSection).type -> 1; // SHT_PROGBITS

def (this is ElfTextSection).alignment -> WORD_SIZE;

def (this is ElfTextSection).encode(out, elf) {
  out.write_data(this.data.get_blob());
}

/**
 * Symbol table (ABI 4-22).
 */
protocol ElfSymbolTable is ElfSection;

def ElfSymbolTable.new(strtab) {
  def result := new ElfSymbolTable {
    strtab := strtab,
    entries := new ArrayList()  
  }
  result.entries.add(new ElfSymbolTableNullEntry());
  result;
}

def (this is ElfSymbolTable).add_local_entry(name, offset, size) {
  def name_index := this.strtab.ensure(name);
  def entry := new ElfSymbolTableEntry(name_index, offset, size);
  this.entries.add(entry);
}

def (this is ElfSymbolTable).info -> this.entries.length + 1;

def (this is ElfSymbolTable).link(elf) -> elf.section_index(elf.strtab);

def (this is ElfSymbolTable).type -> 2; // SHT_SYMTAB

def (this is ElfSymbolTable).name -> ".symtab";

def (this is ElfSymbolTable).alignment -> WORD_SIZE;

def (this is ElfSymbolTable).size -> this.entries.length * this.entry_size;

def (this is ElfSymbolTable).entry_size -> ElfSymbolTableEntry.size;

def (this is ElfSymbolTable).encode(out, elf) {
  for (entry : this.entries)
    entry.encode(out, elf);
}

/**
 * A single symbol table entry.  Corresponds to an Elf32_Sym as defined
 * in the ABI 4-22.
 */
protocol ElfSymbolTableEntry;

def ElfSymbolTableEntry.size -> 4 * WORD_SIZE;

def ElfSymbolTableEntry.new(name_index, offset, size) -> new ElfSymbolTableEntry {
  name_index := name_index,
  offset := offset,
  size := size
}

/**
 * struct Elf32_Sym {
 *   Elf32_Word st_name;
 *   Elf32_Addr st_value;
 *   Elf32_Word st_size; 
 *   unsigned char st_info;
 *   unsigned char st_other;
 *   Elf32_Half st_shndx;
 */
def (this is ElfSymbolTableEntry).encode(out, elf) {
  out.write_int32(this.name_index);
  out.write_int32(this.offset);
  out.write_int32(this.size);
  out.write_int8(2); // STT_FUNC
  out.write_int8(0);
  out.write_int16(1);
}

protocol ElfSymbolTableNullEntry is ElfSymbolTableEntry;

def ElfSymbolTableNullEntry.new() -> new ElfSymbolTableNullEntry { }

def (this is ElfSymbolTableNullEntry).encode(out, elf) {
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int8(0);
  out.write_int8(0);
  out.write_int16(0);
}
