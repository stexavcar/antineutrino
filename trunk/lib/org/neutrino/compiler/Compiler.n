protocol NeutrinoCompiler;

def NeutrinoCompiler.new() -> new NeutrinoCompiler { };

@entry_point("compile")
def compiler_entry_point(args) {
  def in_name := args[0];
  def out_name := args[1];
  new NeutrinoCompiler().compile(in_name, out_name);
}

def (this is NeutrinoCompiler).add_dylib_bridge(binary, name, argc) {
  def bridge := binary.add_code_block(name);
  bridge.enter_frame(0);
  bridge.mov(Memory.at(rEsp), rEax);
  bridge.call(CallTarget.extern("_" + name));
  bridge.exit_frame();  
}

def (this is NeutrinoCompiler).emit_method(universe, method, assm) {
  assm.enter_frame(4 * method.code.local_count);
  def libc := method.get_annotation("libc");
  if libc = null
    then this.emit_plain_method(universe, method, assm);
    else this.emit_libc_method(universe, method, assm);
  assm.exit_frame();
}

def (this is NeutrinoCompiler).emit_plain_method(universe, method, assm) {
  def code := method.code;
  def guide := new SyntaxGuide(code.code, code.literals);
  def should_print := (method.get_annotation("print") != null);
  def root_node := code.root_offset;
  def root_guide := guide.resolve(root_node);
  if should_print
    then print(Unparser.unparse(root_guide, root_node));
  new TypeAnalysis(universe).analyze(root_guide, root_node);
  if should_print
    then print(Unparser.unparse(root_guide, root_node));
  new CodeGenerator(universe, assm).emit(root_guide, root_node);
  assm.pop(rEax);
}

def (this is NeutrinoCompiler).emit_libc_method(universe, method, assm) {
  def libc_name := method.get_annotation("libc")[0];
  // Align ESP to a 16-byte boundary.  Since the stack grows down this
  // will cause the stack to grow.
  assm.ahnd(rEsp, 16rFFFFFFF0);
  assm.mov(rEax, Memory.at_disp(rEbp, 8));
  assm.mov(Memory.at(rEsp), rEax);
  assm.call(Symbol.dylib(libc_name));
}

def (this is NeutrinoCompiler).emit_boilerplate(binary, entry_point) {
  def main := binary.add_code_block("_main");
  main.enter_frame(0);
  main.call(Symbol.local(entry_point));
  main.exit_frame();  
}

def (this is NeutrinoCompiler).build_binary(universe) {
  def binary := new Binary(new Ia386());
  
  // Locate entry point
  def entry_point := with_1cc (yield) {
    for (method : universe.methods) {
      if method.get_annotation("neuneu_entry_point") != null then {
        def name := method.get_annotation("emit")[0];
        yield(name);
      }
    }
    null;
  }
  if entry_point = null
    then fail("No neuneu_entry_point defined.");

  // Emit standard boilerplate
  this.emit_boilerplate(binary, entry_point);

  for (method : universe.methods) {
    def emit := method.get_annotation("emit");
    if emit != null then {
      def name := emit[0];
      def assm := binary.add_code_block(name);
      this.emit_method(universe, method, assm);
    }
  }
  binary;
}

protocol CompilerGrower;

def CompilerGrower.new() -> new CompilerGrower {
  handler_table := CompilerGrower.new_handler_table()
}

def (this is CompilerGrower).grow(tag, payload) {
  def handler := this.handler_table[tag];
  if handler = null then
    fail("Don't know how to grow a ${tag}.");
  handler(payload);
}

def (this is NeutrinoCompiler).read_universe(filename) {
  def raw_data := open_file(filename).read_binary();
  new Plankton(raw_data, new CompilerGrower()).unmarshal();
}

def (this is NeutrinoCompiler).compile(in_name, out_name) {
  def universe := this.read_universe(in_name);
  def binary := this.build_binary(universe);
  def data := binary.encode;
  open_file(out_name).write_binary(data);  
}
