protocol NeutrinoCompiler;

def NeutrinoCompiler.new() -> new NeutrinoCompiler { };

@entry_point("compile")
def compiler_entry_point(args) {
  def in_name := args[0];
  def out_name := args[1];
  new NeutrinoCompiler().compile(in_name, out_name);
}

def (this is NeutrinoCompiler).add_dylib_bridge(binary, name, argc) {
  def bridge := binary.add_code_block(name);
  bridge.enter_frame();
  bridge.mov(rEax, deref(rEsp));
  bridge.call(CallTarget.extern("_" + name));
  bridge.exit_frame();  
}

def (this is NeutrinoCompiler).emit_method(universe, method, assm) {
  assm.enter_frame();
  def libc := method.get_annotation("libc");
  if libc = null
    then this.emit_plain_method(universe, method, assm);
    else this.emit_libc_method(universe, method, assm);
  assm.exit_frame();
}

def (this is NeutrinoCompiler).emit_plain_method(universe, method, assm) {
  def code := method.code;
  def guide := new SyntaxGuide(code.code, code.literals);
  def root_node := code.root_offset;
  def root_guide := guide.resolve(root_node);
  new TypeAnalysis(universe).analyze(root_guide, root_node);
  new CodeGenerator(universe, assm).emit(root_guide, root_node);
  assm.pop(rEax);
}

def (this is NeutrinoCompiler).emit_libc_method(universe, method, assm) {
  def libc_name := method.get_annotation("libc")[0];
  assm.ahnd(16rFFFFFFF0, rEsp);
  assm.mov(rEax, deref(rEsp));
  assm.call(CallTarget.extern(libc_name));
}

def (this is NeutrinoCompiler).emit_boilerplate(binary, entry_point) {
  def main := binary.add_code_block("_main");
  main.enter_frame();
  main.call(CallTarget.local(entry_point));
  main.exit_frame();  
}

def (this is NeutrinoCompiler).build_binary(universe) {
  def binary := new Binary(new Ia386());
  
  // Locate entry point
  def entry_point := with_1cc (yield) {
    for (method : universe.methods) {
      if method.get_annotation("neuneu_entry_point") != null then {
        def name := method.get_annotation("emit")[0];
        yield(name);
      }
    }
    null;
  }
  if entry_point = null
    then fail("No neuneu_entry_point defined.");

  // Emit standard boilerplate
  this.emit_boilerplate(binary, entry_point);

  for (method : universe.methods) {
    def emit := method.get_annotation("emit");
    if emit != null then {
      def name := emit[0];
      def assm := binary.add_code_block(name);
      this.emit_method(universe, method, assm);
    }
  }
  binary;
}

protocol CompilerGrower;

def CompilerGrower.new() -> new CompilerGrower {
  handler_table := CompilerGrower.new_handler_table()
}

def (this is CompilerGrower).grow(tag, payload) {
  def handler := this.handler_table[tag];
  if handler = null then
    fail("Don't know how to grow a ${tag}.");
  handler(payload);
}

def (this is NeutrinoCompiler).read_universe(filename) {
  def raw_data := open_file(filename).read_binary();
  new Plankton(raw_data, new CompilerGrower()).unmarshal();
}

def (this is NeutrinoCompiler).compile(in_name, out_name) {
  def universe := this.read_universe(in_name);
  def binary := this.build_binary(universe);
  def data := binary.encode;
  open_file(out_name).write_binary(data);  
}
