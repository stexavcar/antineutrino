protocol PrimitiveCollection;

@native("array") protocol PrimitiveArray is Sequence, PrimitiveCollection;

def (this is PrimitiveArray)[index is Integer] -> internal "array[]";

def (this is PrimitiveArray).length -> internal "array.length";

def (this is PrimitiveArray)+(that is PrimitiveArray) {
  def result := new MutablePrimitiveArray(this.length + that.length);
  for (i : 0 .. this.length)
    result[i] := this[i];
  for (i : 0 .. that.length)
    result[this.length + i] := that[i];
  result;
}

def (this is PrimitiveArray)=(that is PrimitiveArray)
 -> (this.length = that.length) and (with_escape (yield) {
   for (i : 0 .. this.length) {
     if this[i] != that[i]
       then yield(false);
   }
   true;
 });

def (this is PrimitiveArray).for(fun) {
  for (i : 0 .. this.length)
    fun(this[i]);
}

def (this is PrimitiveArray)[slice is Interval] {
  def a := new MutablePrimitiveArray(Math.abs(slice.to - slice.from));
  ref i := 0;
  for (idx : slice) {
    a[i] := this[idx];
    i := i + 1;
  }
  a;
}

@native("mutarr") protocol MutablePrimitiveArray is PrimitiveArray;

def MutablePrimitiveArray.new(size is Integer) -> internal "mutprimarr";

def (this is MutablePrimitiveArray)[i is Integer]:=(value) -> internal "mutarr.set";

@native("byte_array") protocol ByteArray is PrimitiveArray;

def (this is ByteArray)[index is Integer] -> internal "byte_array[1]";

def (this is ByteArray).int32_at(index is Integer) -> internal "byte_array[4]";

def (this is ByteArray).length -> internal "byte_array.length";

@native("mutbytarr") protocol MutablePrimitiveByteArray is ByteArray;

def MutablePrimitiveByteArray.new(size is Integer) -> internal "mutprimbytarr";

def (this is MutablePrimitiveByteArray)[i is Integer]:=(value is Integer) -> internal "mutbytarr.set";

