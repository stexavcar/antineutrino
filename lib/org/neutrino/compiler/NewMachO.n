// cpu_type_t
def CPU_TYPE_VAX := 1;
def CPU_TYPE_MC680x0 := 6;
def CPU_TYPE_X86 := 7;
def CPU_TYPE_I386 := CPU_TYPE_X86;
def CPU_TYPE_X86_64 := CPU_TYPE_X86 | CPU_ARCH_ABI64;
def CPU_TYPE_MC98000 := 10;
def CPU_TYPE_HPPA := 11;
def CPU_TYPE_MC88000 := 13;
def CPU_TYPE_SPARC := 14;
def CPU_TYPE_I860 := 15;
def CPU_TYPE_POWERPC := 18;
def CPU_TYPE_POWERPC64 := CPU_TYPE_POWERPC | CPU_ARCH_ABI64;

// file types
def MH_OBJECT := 16r1;
def MH_EXECUTE := 16r2;
def MH_BUNDLE := 16r8;
def MH_DYLIB := 16r6;
def MH_PRELOAD := 16r5;
def MH_CORE := 16r4;
def MH_DYLINKER := 16r7;
def MH_DSYM := 16rA;

// load commands
def LC_UUID := 16r1B;
def LC_SEGMENT := 16r01;
def LC_SEGMENT_64 := 16r19;
def LC_SYMTAB := 16r2;
def LC_DYSYMTAB := 16rB;
def LC_THREAD := 16r4;
def LC_UNIXTHREAD := 16r5;
def LC_LOAD_DYLIB := 16rC;
def LC_ID_DYLIB := 16rD;
def LC_PREBOUND_DYLIB := 16r10;
def LC_LOAD_DYLINKER := 16rE;
def LC_ID_DYLINKER := 16rF;
def LC_ROUTINES := 16r11;
def LC_TWOLEVEL_HINTS := 16r16;
def LC_SUB_FRAMEWORK := 16r12;
def LC_SUB_UMBRELLA := 16r13;
def LC_SUB_LIBRARY := 16r15;
def LC_SUB_CLIENT := 16r14;

def PAGE_SIZE := 16r1000;

/**
 * A Mach-O file.  Use the add_*_command functions to add load commands,
 * and methods on the segment_commands to add segments and sections.
 * 
 * See http://developer.apple.com/documentation/DeveloperTools/
 * Conceptual/MachORuntime/index.html for the full specification.
 */
protocol MachO;

/**
 * Create a new Mach-O with the given properties.  Load commands and
 * sections are added after construction.
 */
def MachO.new(cputype, cpusubtype, filetype, flags) -> new MachO {
  cputype := cputype,
  cpusubtype := cpusubtype,
  filetype := filetype,
  commands := new ArrayList(0),
  flags := flags
};

/**
 * Returns the total size of the load commands contained in this
 * binary.
 */
def (this: MachO).cmdsize {
  ref result := 0;
  for (def command : this.commands)
    result := result + command.cmdsize;
  result;
}

def (this: MachO).write_binary(out) {
  this.write_header(out);
  this.write_load_commands(out);
  this.write_segments(out);
}

/**
 * Write this binary to the given binary stream.
 * 
 * struct mach_header {
 *   uint32_t magic;
 *   cpu_type_t cputype;
 *   cpu_subtype_t cpusubtype;
 *   uint32_t filetype;
 *   uint32_t ncmds;
 *   uint32_t sizeofcmds;
 *   uint32_t flags;
 * };
 */
def (this: MachO).write_header(out) {
  out.write_int32(16rFEEDFACE);
  out.write_int32(this.cputype);
  out.write_int32(this.cpusubtype);
  out.write_int32(this.filetype);
  out.write_int32(this.commands.length);
  out.write_int32(this.cmdsize);
  out.write_int32(this.flags);
}

def (this: MachO).header_size -> 28;

def align(value, factor) {
  if (value % factor) = 0 then
    value
  else
    value + (factor - (value % factor));
}

def page_size_ceil(size) -> align(size, PAGE_SIZE);

def (this: MachO).write_load_commands(out) {
  ref fileoff := page_size_ceil(this.cmdsize + this.header_size);
  for (def command : this.commands) {
    command.write_load_command(out, fileoff);
    fileoff := page_size_ceil(fileoff + command.filesize);
  }
}

def (this: MachO).write_segments(out) {
  ref fileoff := page_size_ceil(this.cmdsize + this.header_size);
  out.pad_to(fileoff);
  for (def command : this.commands) {
    for (def segment : command.segments) {
      segment.write_sections(out, fileoff);
      fileoff := page_size_ceil(fileoff + command.filesize);
      out.pad_to(fileoff);
    }
  }
}

/**
 * Return a binary blob containing the encoded contents of this Mach-O.
 */
def (this: MachO).to_blob {
  def out := new BlobStream;
  this.write_binary(out);
  out.get_blob();
}

/**
 * Returns a new segment_command contained in this Mach-O.
 */
def (this: MachO).add_segment_command(segname) {
  def result := new SegmentCommand {
    segname := segname,
    sections := new ArrayList(0)
  };
  this.commands.add(result);
  result;
}

protocol LoadCommand;

def (this: LoadCommand).segments -> fn for (fun) -> null;

/**
 * A load command corresponding to a segment.
 */
protocol SegmentCommand;
def SegmentCommand is LoadCommand;

/*
 * struct segment_command {
 *   uint32_t cmd;
 *   uint32_t cmdsize;
 *   char segname[16];
 *   uint32_t vmaddr;
 *   uint32_t vmsize;
 *   uint32_t fileoff;
 *   uint32_t filesize;
 *   vm_prot_t maxprot;
 *   vm_prot_t initprot;
 *   uint32_t nsects;
 *   uint32_t flags;
 * };
 */
def (this: SegmentCommand).write_load_command(out, fileoff) {
  out.write_int32(LC_SEGMENT);
  out.write_int32(this.cmdsize);
  out.write_c_string(this.segname, 16);
  out.write_int32(fileoff);
  def filesize := this.filesize;
  out.write_int32(filesize);
  out.write_int32(fileoff);
  out.write_int32(filesize);
  out.write_int32(7); // maxprot
  out.write_int32(5); // initprot
  out.write_int32(this.sections.length);
  out.write_int32(0); // flags
  this.write_section_headers(out, fileoff);
}

def (this: SegmentCommand).segments -> fn for (fun) -> fun(this);

def (this: SegmentCommand).filesize -> 1;

def (this: SegmentCommand).cmdsize -> 56 + (this.sections.length * Section.size);

def (this: SegmentCommand).write_sections(out, fileoff) {
  for (def section : this.sections)
    section.write_contents(out);
}

def (this: SegmentCommand).write_section_headers(out, fileoff) {
  ref off := fileoff;
  for (def section : this.sections) {
    section.write_header(out, off);
    off := off + section.filesize;
  }
}

def (this: SegmentCommand).add_section(sectname, contents) {
  def result := new Section {
    parent := this,
    sectname := sectname,
    contents := contents
  };
  this.sections.add(result);
  result;
}

protocol Section;

def Section.size -> 68;

/*
 * struct section {
 *   char sectname[16];
 *   char segname[16];
 *   uint32_t addr;
 *   uint32_t size;
 *   uint32_t offset;
 *   uint32_t align;
 *   uint32_t reloff;
 *   uint32_t nreloc;
 *   uint32_t flags;
 *   uint32_t reserved1;
 *   uint32_t reserved2;
 * };
 */
def (this: Section).write_header(out, fileoff) {
  out.write_c_string(this.sectname, 16);
  out.write_c_string(this.parent.segname, 16);
  out.write_int32(fileoff);
  out.write_int32(this.filesize);
  out.write_int32(fileoff);
  out.write_int32(2);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(16r80000400);
  out.write_int32(0);
  out.write_int32(0);
}

def (this: Section).write_contents(out) {
  print(out);
  out.write_data(this.contents, 0, this.contents.length);
}

def (this: Section).filesize -> this.contents.length;
