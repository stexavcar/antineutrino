protocol ElfFormat;

def ElfFormat.new() -> new ElfFormat { };

def (this is ElfFormat).builder(binary) -> new Elf(binary);

protocol Elf;

def Elf.new(binary) {
  def string_table := new ElfStringTable();
  def result := new Elf {
    binary := binary,
    string_table := string_table,
    sections := new ArrayList [ string_table ]
  }
  result;
}

def (this is Elf).section_index(section) {
  with_1cc (return) {
    for (i : 0 .. this.sections.length) {
      if this.sections[i] = section
        then return(i);
    }
    null;
  }
}

def (this is Elf).add_code_block(name, code) { }

def (this is Elf).finalize() { }

def (this is Elf).encode(out) {
  this.encode_header(out); 
}

/*
 * typedef struct Elf32_Ehdr {
 *   unsigned char e_ident[EI_NIDENT];
 *   Elf32_Half e_type;
 *   Elf32_Half e_machine;
 *   Elf32_Word e_version;
 *   Elf32_Addr e_entry;
 *   Elf32_Off e_phoff;
 *   Elf32_Off e_shoff;
 *   Elf32_Word e_flags;
 *   Elf32_Half e_ehsize;
 *   Elf32_Half e_phentsize;
 *   Elf32_Half e_phnum;
 *   Elf32_Half e_shentsize;
 *   Elf32_Half e_shnum;
 *   Elf32_Half e_shstrndx;
 * }
 */
def (this is Elf).encode_header(out) {
  this.encode_identification(out);
  out.write_int16(1); // ET_REL
  out.write_int16(3); // EM_386
  out.write_int32(1); // EV_CURRENT
  out.write_int32(0); // No entry point
  out.write_int32(0); // No header table
  out.write_int32(0); // No section headers
  out.write_int32(0); // No flags
  out.write_int16(52); // Size of this header
  out.write_int16(0); // Size of program headers
  out.write_int16(0); // Number of program headers
  def nsect := this.sections.length;
  out.write_int16(nsect * ElfSection.size); // Size of section headers
  out.write_int16(nsect); // Number of section headers
  def strndx := this.section_index(this.string_table);
  out.write_int16(strndx); // Section header string table index
  for (section : this.sections)
    this.encode_section(out, section);
}

/*
 * typedef struct Elf32_Shdr {
 *   Elf32_Word sh_name;
 *   Elf32_Word sh_type;
 *   Elf32_Word sh_flags;
 *   Elf32_Addr sh_addr;
 *   Elf32_Off sh_offset;
 *   Elf32_Word sh_size;
 *   Elf32_Word sh_link;
 *   Elf32_Word sh_info;
 *   Elf32_Word sh_addralign;
 *   Elf32_Word sh_entsize;
 * }
 */
def (this is Elf).encode_section(out, section) {
  out.write_int32(this.string_table[section.name]);
  out.write_int32(section.type);
  out.write_int32(0);
}

def (this is Elf).encode_identification(out) {
  out.write_int32(16r464C457F); // MAGIC
  out.write_int8(1); // ELFCLASS32
  out.write_int8(1); // ELFDATA2LSB
  out.write_int8(1); // VERSION
  for (i : 7 .. 16)
    out.write_int8(0); // PAD
}

protocol ElfSection;

def ElfSection.size -> 10 * WORD_SIZE;

protocol ElfStringTable is ElfSection;

def ElfStringTable.new() -> new ElfStringTable {
  table := new HashMap()
}

def (this is ElfStringTable).name -> ".strtab";

def (this is ElfStringTable).type -> 3; // SHT_STRTAB



def (this is ElfStringTable)[key] {
  def prev := this.table[key];
  if prev = null then {
    def index := this.table.size;
    this.table[prev] := index;
    index;
  } else {
    prev;
  }
}
