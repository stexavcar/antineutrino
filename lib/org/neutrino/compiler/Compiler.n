protocol Platform;

def Platform.new(object_format, architecture) -> new Platform {
  object_format_name := object_format,
  architecture_name := architecture
}

def (this is Platform).architecture {
  def name := this.architecture_name;
  if name = "ia386"
    then new Ia386();
    else null;
}

def (this is Platform).object_format {
  def name := this.object_format_name;
  if name = "elf" then
    new ElfFormat();
  else if name = "mach-o" then
    new MachOFormat();
  else
    null;
}

protocol NeutrinoCompiler;

def NeutrinoCompiler.new() -> new NeutrinoCompiler {
  methods_seen := new HashMap(),
  method_worklist := new ArrayList()
};

@entry_point("compile")
def compiler_entry_point(args) {
  def object_format := args[0];
  def architecture := args[1];
  def platform := new Platform(object_format, architecture);
  def in_name := args[2];
  def out_name := args[3];
  new NeutrinoCompiler().compile(platform, in_name, out_name);
}

def (this is NeutrinoCompiler).add_dylib_bridge(binary, name, argc) {
  def bridge := binary.add_code_block(name);
  bridge.enter_frame(0);
  bridge.mov(Memory.at(rEsp), rEax);
  bridge.call(CallTarget.extern("_" + name));
  bridge.exit_frame();  
}

def (this is NeutrinoCompiler).emit_method(universe, method, assm) {
  def libc := method.get_annotation("libc");
  if libc = null
    then this.emit_plain_method(universe, method, assm);
    else this.emit_libc_method(universe, method, assm);
  assm.exit_frame();
}

def (this is NeutrinoCompiler).emit_plain_method(universe, method, assm) {
  def should_print := (method.get_annotation("print") != null);
  method.ensure_analyzed(universe);
  assm.enter_frame(4 * method.code.local_count);
  new CodeGenerator(universe, assm, this, method).generate(method.body);
  assm.pop(rEax);
}

def (this is NeutrinoCompiler).emit_libc_method(universe, method, assm) {
  def libc_name := method.get_annotation("libc")[0];
  def argc := method.params.length - 1; // discount the receiver
  assm.enter_frame(4 * argc);
  // Align ESP to a 16-byte boundary.  Since the stack grows down this
  // will cause the stack to grow.
  assm.ahnd(rEsp, 16rFFFFFFF0);
  for (i : 0 .. argc) {
    def index := argc - i - 1;
    assm.mov(rEax, Memory.at_disp(rEbp, 8 + (4 * index)));
    assm.mov(Memory.at_disp(rEsp, 4 * index), rEax);
  }
  assm.call(Symbol.dylib(libc_name));
}

def (this is NeutrinoCompiler).emit_boilerplate(binary, entry_point) {
  def main := binary.add_code_block(binary.file_format.entry_point_name);
  main.enter_frame(0);
  main.call(Symbol.local(entry_point));
  main.exit_frame();  
}

def get_binary_name(method) {
  def result := new StringStream();
  result.add(method.name);
  result.add("(");
  ref first := true;
  for (param : method.params) {
    if first
      then first := false;
      else result.add(",");
    if param.is_protocol
      then result.add("%");
    result.add(param.type);
  }
  result.add(")");  
  result.to_string();
}

def (this is NeutrinoCompiler).ensure_generated(method) {
  def name := get_binary_name(method);
  if this.methods_seen[name] = null then {
    this.methods_seen[name] := false;
    this.method_worklist.add(method);
  }
}

def (this is NeutrinoCompiler).emit_methods(universe, binary) {
  with_escape (done) {
    Control.repeat(fn {
      if this.method_worklist.length = 0
        then done(null);
      def next := this.method_worklist.remove_last();
      def name := get_binary_name(next);
      if not this.methods_seen[name] then {
        def assm := binary.add_code_block(name);
        this.methods_seen[name] := true;
        this.emit_method(universe, next, assm);
      }
    });
  }
}

def (this is NeutrinoCompiler).emit_data(binary) {
  def assm := binary.add_data_block("x");
  assm.write(small_integer_t.of(5));
}

def (this is NeutrinoCompiler).build_binary(platform, universe) {
  def binary := new Binary(platform.architecture, platform.object_format);
  // Locate entry point
  def entry_point_method := with_escape (yield) {
    for (method : universe.methods) {
      if method.get_annotation("neuneu_entry_point") != null
        then yield(method);
    }
    null;
  }
  if entry_point_method = null
    then fail("No neuneu_entry_point defined.");

  // Emit standard boilerplate
  this.emit_boilerplate(binary, get_binary_name(entry_point_method));
  this.ensure_generated(entry_point_method);
  this.emit_methods(universe, binary);
  this.emit_data(binary);
  binary;
}

protocol CompilerGrower;

def CompilerGrower.new() -> new CompilerGrower {
  handler_table := CompilerGrower.new_handler_table()
}

def (this is CompilerGrower).get_codec(tag) {
  def handler := this.handler_table[tag];
  if handler = null then
    fail("Has no codec for ${tag}.");
  handler;
}

def (this is NeutrinoCompiler).read_universe(filename) {
  def raw_data := open_file(filename).read_binary();
  def in := new BlobInputStream(raw_data);
  new PlanktonDecoder(in, new CompilerGrower()).read();
}

def (this is NeutrinoCompiler).compile(platform, in_name, out_name) {
  def universe := this.read_universe(in_name);
  def binary := this.build_binary(platform, universe);
  def data := binary.encode;
  open_file(out_name).write_binary(data);  
}
