protocol Register;

def Register.new(index) -> new Register { index := index };

protocol Deref;

def Deref.new(reg is Register) -> new Deref { reg := reg };

def deref(val) -> new Deref(val);

def rEax := new Register(0);
def rEcx := new Register(1);
def rEdx := new Register(2);
def rEbx := new Register(3);
def rEsp := new Register(4);
def rEbp := new Register(5);
def rEsi := new Register(6);
def rEdi := new Register(7);

protocol CallTarget;

protocol LocalCallTarget;

def CallTarget.local(name) -> new LocalCallTarget { name := name };

protocol ExternalCallTarget;

def CallTarget.extern(name) -> new ExternalCallTarget { name := name };

protocol AssemblerIa386;

def AssemblerIa386.new(binary, name) -> new AssemblerIa386 {
  binary := binary,
  name := name,
  stream := new BlobStream(),
  fixups := new ArrayList()
}

def (this is AssemblerIa386).finalize() {
  for (fixup : this.fixups)
    fixup();
}

def (this is AssemblerIa386).write_mod_rm(mod, reg, rm) {
  this.stream.write_int8((mod << 6) | (reg << 3) | rm);
}

def (this is AssemblerIa386).write_sib(scale, index, base) {
  this.stream.write_int8((scale << 6) | (index << 3) | base);
}

// B8 +rd -> MOV r32, imm32
def (this is AssemblerIa386).mov(imm32 is Integer, dest is Register) {
  this.stream.write_int8(16rB8 + dest.index);
  this.stream.write_int32(imm32);
}

def kDeref := 2r00;
def kReg := 2r11;

def kScaleOne := 2r00;
def kScaleTwo := 2r01;
def kScaleFour := 2r10;
def kScaleEight := 2r11;

// C7 /0 -> MOV r/m32, imm32
def (this is AssemblerIa386).mov(imm32 is Integer, dest is Deref) {
  this.stream.write_int8(16rC7);
  this.write_mod_rm(kDeref, 0, 4);
  this.write_sib(kScaleOne, 4, dest.reg.index);
  this.stream.write_int32(imm32);
}

// 89 /r -> MOV r/m32, r32
def (this is AssemblerIa386).mov(src is Register, dest is Register) {
  this.stream.write_int8(16r89);
  this.write_mod_rm(kReg, src.index, dest.index);
}

// 81 /5 id -> SUB r/m32, imm32
def (this is AssemblerIa386).sub(imm32 is Integer, reg is Register) {
  this.stream.write_int8(16r81);
  this.write_mod_rm(kReg, 5, reg.index);
  this.stream.write_int32(imm32);
}

def (this is AssemblerIa386).push(reg is Register) {
  this.stream.write_int8(16r50 + reg.index);
}

def (this is AssemblerIa386).ret() {
  this.stream.write_int8(16rC3);
}

def (this is AssemblerIa386).leave() {
  this.stream.write_int8(16rC9);
}

def (this is AssemblerIa386).enter_frame() {
  this.push(rEbp);
  this.mov(rEsp, rEbp);
  this.sub(16r18, rEsp);
}

def (this is AssemblerIa386).exit_frame() {
  this.leave();
  this.ret();
}

def (this is AssemblerIa386).call(target is LocalCallTarget) {
  this.stream.write_int8(16rE8);
  def reloff := this.stream.length;
  this.stream.write_int32(0);
  this.fixups.add(fn {
    def ownoff := this.binary.code_block_offset(this.name);
    def codeoff := this.binary.code_block_offset(target.name);
    this.stream.rewrite_int32(reloff, codeoff - (ownoff + reloff + 4));
  });
}

def (this is AssemblerIa386).call(target is ExternalCallTarget) {
  this.stream.write_int8(16rE8);
  def reloff := this.stream.length;
  this.stream.write_int32(0);
  def index := this.binary.register_extern(target.name, this.name, reloff);
  this.fixups.add(fn {
    def ownoff := this.binary.code_block_offset(this.name);
    def codeoff := this.binary.extern_offset(index);
    this.stream.rewrite_int32(reloff, codeoff - (ownoff + reloff + 4));
  });  
}

def (this is AssemblerIa386).int3() -> this.stream.write_int8(16rCC);

def (this is AssemblerIa386).length -> this.stream.length;

def (this is AssemblerIa386).code -> this.stream.get_blob();

protocol Ia386;

def Ia386.new() -> new Ia386 { };

def (this is Ia386).new_assembler(binary, name)
 -> new AssemblerIa386(binary, name);
