// cpu_type_t
def CPU_TYPE_VAX := 1;
def CPU_TYPE_MC680x0 := 6;
def CPU_TYPE_X86 := 7;
def CPU_TYPE_I386 := CPU_TYPE_X86;
def CPU_TYPE_X86_64 := CPU_TYPE_X86 | CPU_ARCH_ABI64;
def CPU_TYPE_MC98000 := 10;
def CPU_TYPE_HPPA := 11;
def CPU_TYPE_MC88000 := 13;
def CPU_TYPE_SPARC := 14;
def CPU_TYPE_I860 := 15;
def CPU_TYPE_POWERPC := 18;
def CPU_TYPE_POWERPC64 := CPU_TYPE_POWERPC | CPU_ARCH_ABI64;

// file types
def MH_OBJECT := 16r1;
def MH_EXECUTE := 16r2;
def MH_BUNDLE := 16r8;
def MH_DYLIB := 16r6;
def MH_PRELOAD := 16r5;
def MH_CORE := 16r4;
def MH_DYLINKER := 16r7;
def MH_DSYM := 16rA;

// load commands
def LC_UUID := 16r1B;
def LC_SEGMENT := 16r01;
def LC_SEGMENT_64 := 16r19;
def LC_SYMTAB := 16r2;
def LC_DYSYMTAB := 16rB;
def LC_THREAD := 16r4;
def LC_UNIXTHREAD := 16r5;
def LC_LOAD_DYLIB := 16rC;
def LC_ID_DYLIB := 16rD;
def LC_PREBOUND_DYLIB := 16r10;
def LC_LOAD_DYLINKER := 16rE;
def LC_ID_DYLINKER := 16rF;
def LC_ROUTINES := 16r11;
def LC_TWOLEVEL_HINTS := 16r16;
def LC_SUB_FRAMEWORK := 16r12;
def LC_SUB_UMBRELLA := 16r13;
def LC_SUB_LIBRARY := 16r15;
def LC_SUB_CLIENT := 16r14;

def PAGE_SIZE := 16r1000;
def WORD_SIZE := 4;

protocol MachO;

def MachO.new() {
  def text := new TextSection();
  def strings := new StringTable();
  def symbols := new SymbolTable();
  new MachO {
    text := text,
    strings := strings,
    symbols := symbols,
    sections := new ArrayList() [ text ],
    dark_sections := new ArrayList() [ strings, symbols ]
  };
}

def MachO.header_size -> 7 * WORD_SIZE;

def (this is MachO).encode(out) {
  this.encode_mach_header(out);
  this.encode_load_commands(out);
  this.encode_sections(out);
}

def (this is MachO).add_code_block(name, code) {
  def name_index := this.strings.add(name);
  def code_start := this.text.add_block(name_index, code);
  this.symbols.add(name_index, this.segment_fileoff + code_start);
}

protocol TextSection;

def TextSection.new() -> new TextSection {
  blocks := new ArrayList(),
  rLength := new_ref(0)
};

def (this is TextSection).length -> this.rLength.get();

def (this is TextSection).length:=(value) -> this.rLength.set(value);

def (this is TextSection).segname -> "__TEXT";

def (this is TextSection).sectname -> "__text";

def (this is TextSection).add_block(name, code) {
  this.blocks.add(new { name := name, code := code });
  def result := this.length;
  this.length := this.length + code.length;
  result;
}

def (this is TextSection).size {
  ref result := 0;
  for (def block : this.blocks)
    result := result + block.code.length;
  result;
}

def (this is TextSection).encode(out) {
  ref offset := out.length;
  for (def block : this.blocks) {
    out.write_data(block.code);
    offset := offset + block.code.length;
    out.pad_to(offset);
  }
}

def align(value, factor) {
  if (value % factor) = 0 then
    value
  else
    value + (factor - (value % factor));
}

protocol StringTable;

def StringTable.new() {
  def result := new StringTable {
    strings := new ArrayList()
  };
  result.add("");
  result;
}

def (this is StringTable).add(name) {
  this.strings.add(name);
  this.strings.length - 1;
}

def (this is StringTable).encode(out) {
  for (def str : this.strings)
    out.write_c_string(str);
}

def (this is StringTable).size {
  ref result := 0;
  for (def str : this.strings)
    result := result + str.length + 1;
  result;
}

def (this is StringTable).length -> this.strings.length;

protocol SymbolTable;

def SymbolTable.new() -> new SymbolTable {
  symbols := new ArrayList()
};

def (this is SymbolTable).add(name_index, code_start) {
  this.symbols.add(new Symbol(name_index, code_start));
}

def (this is SymbolTable).length -> this.symbols.length;

def (this is SymbolTable).encode(out) {
  for (def symbol : this.symbols)
    symbol.encode(out);
}

def (this is SymbolTable).size -> this.length * Symbol.size;

protocol Symbol;

def Symbol.new(name, start) -> new Symbol { name := name, start := start };

def Symbol.size -> 3 * WORD_SIZE;

def (this is Symbol).encode(out) {
  out.write_int32(this.name);
  out.write_int8(16rF);
  out.write_int8(1);
  out.write_int16(0);
  out.write_int32(this.start);
}

/*
 * struct mach_header {
 *   uint32_t magic;
 *   cpu_type_t cputype;
 *   cpu_subtype_t cpusubtype;
 *   uint32_t filetype;
 *   uint32_t ncmds;
 *   uint32_t sizeofcmds;
 *   uint32_t flags;
 * };
 */
def (this is MachO).encode_mach_header(out) {
  out.write_int32(16rFEEDFACE);
  out.write_int32(CPU_TYPE_X86);
  out.write_int32(3); // cpusubtype
  out.write_int32(MH_OBJECT);
  out.write_int32(this.ncmds);
  out.write_int32(this.sizeofcmds);
  out.write_int32(5);
}

def (this is MachO).header_size -> 7 * WORD_SIZE;

def (this is MachO).segment_fileoff -> this.header_size + this.sizeofcmds;

def (this is MachO).nsects -> this.sections.length;

def (this is MachO).ncmds -> 2;

def (this is MachO).sizeofcmds -> this.sizeof_segment_command + this.sizeof_symtab_command;

def (this is MachO).sizeof_segment_command -> SEGMENT_COMMAND_SIZE + (this.nsects * SECTION_HEADER_SIZE);

def (this is MachO).sizeof_symtab_command -> 6 * WORD_SIZE;

def SEGMENT_COMMAND_SIZE := 56;
def SECTION_HEADER_SIZE := 68;

def (this is MachO).encode_load_commands(out) {
  this.encode_segment_command(out);
  this.encode_section_headers(out);
  this.encode_symtab_command(out);
}

def (this is MachO).encode_symtab_command(out) {
  out.write_int32(LC_SYMTAB);
  out.write_int32(this.sizeof_symtab_command);
  out.write_int32(this.offset_of(this.symbols));
  out.write_int32(this.symbols.length);
  out.write_int32(this.offset_of(this.strings));
  out.write_int32(this.strings.size);
}

/*
 * struct segment_command {
 *   uint32_t cmd;
 *   uint32_t cmdsize;
 *   char segname[16];
 *   uint32_t vmaddr;
 *   uint32_t vmsize;
 *   uint32_t fileoff;
 *   uint32_t filesize;
 *   vm_prot_t maxprot;
 *   vm_prot_t initprot;
 *   uint32_t nsects;
 *   uint32_t flags;
 * };
 */
def (this is MachO).encode_segment_command(out) {
  out.write_int32(LC_SEGMENT);
  out.write_int32(this.sizeof_segment_command);
  out.write_c_string("", 16);
  def size := this.segment_size;
  out.write_int32(0);
  out.write_int32(size);
  out.write_int32(this.segment_fileoff);
  out.write_int32(size);
  out.write_int32(7);
  out.write_int32(5);
  out.write_int32(this.nsects);
  out.write_int32(0); // flags
}

/*
 * struct section {
 *   char sectname[16];
 *   char segname[16];
 *   uint32_t addr;
 *   uint32_t size;
 *   uint32_t offset;
 *   uint32_t align;
 *   uint32_t reloff;
 *   uint32_t nreloc;
 *   uint32_t flags;
 *   uint32_t reserved1;
 *   uint32_t reserved2;
 * };
 */
def (this is MachO).encode_section_headers(out) {
  ref fileoff := this.segment_fileoff;
  for (def section : this.sections) {
    out.write_c_string(section.sectname, 16);
    out.write_c_string(section.segname, 16);
    out.write_int32(fileoff);
    def size := section.size;
    out.write_int32(size);
    out.write_int32(fileoff);
    out.write_int32(2);
    out.write_int32(0);
    out.write_int32(0);
    out.write_int32(16r80000400);
    out.write_int32(0);
    out.write_int32(0);
    fileoff := fileoff + size;
  }
}

def (this is MachO).all_sections -> this.sections + this.dark_sections;

def (this is MachO).encode_sections(out) {
  ref fileoff := this.segment_fileoff;
  for (def section : this.all_sections) {
    out.pad_to(fileoff);
    section.encode(out);
    def size := section.size;
    fileoff := fileoff + size;
  }
  out.pad_to(fileoff);
}

def (this is MachO).offset_of(target) {
  ref fileoff := this.segment_fileoff;
  with_1cc return ->
    for (def section : this.all_sections) {
      if section = target then {
        return.fire(fileoff);
      }
      def size := section.size;
      fileoff := fileoff + size;
    };
}

def (this is MachO).segment_size {
  ref result := 0;
  for (def section : this.sections)
    result := result + section.size;
  result;
}

def (this is MachO).encode_segments(out, layout) {
  for (def i : 0 .. this.elements.length) {
    out.pad_to(layout[i].fileoff);
    this.elements[i].encode_segment(out, layout[i]);
  }
  out.pad_to(align(out.length, PAGE_SIZE));
}

def (this is MachO).ncmds {
  ref result := 0;
  for (def element : this.elements)
    result := result + element.load_command_count;
  result;
}

def (this is MachO).sizeofcmds {
  ref result := 0;
  for (def element : this.elements)
    result := result + element.load_command_size;
  result;
}
