def PAGE_SIZE := 16r1000;
def WORD_ALIGN := 2;
def WORD_SIZE := 1 << WORD_ALIGN;

// Factory for MachO objects.  Used to configure the binary builder.
protocol MachOFormat;

def MachOFormat.new() -> new MachOFormat { };

def (this is MachOFormat).builder(binary) -> new MachO(binary);

// A mach-o file, or at least the parts of it that are relevant for
// generating object files for neutrino programs.
protocol MachO;

def MachO.new(binary) {
  def reloc_table := new RelocationTable();
  def text := new TextSection(reloc_table);
  def cstrings := new CStringSection();
  def strings := new StringTable();
  def symbols := new SymbolTable(strings);
  def indirect_symbols := new IndirectSymbols();
  def jump_table := new JumpTable();
  new MachO {
    binary := binary,
    text := text,
    cstrings := cstrings,
    strings := strings,
    symbols := symbols,
    indirect_symbols := indirect_symbols,
    jump_table := jump_table,
    reloc_table := reloc_table,
    sections := new ArrayList() [ text, jump_table, cstrings ],
    dark_sections := new ArrayList() [ strings, symbols, indirect_symbols, reloc_table ],
    layout := new Layouter(),
    local_calls := new ArrayList(),
    dylib_calls := new ArrayList(),
    dysym_indices := new HashMap()
  }
}

// Used by the binary to create a new code block.
def (this is MachO).add_code_block(name, code) {
  this.symbols.add_local(name);
  this.text.add_block(name, code);
}

// Called by the binary when all data has been added to this object.
def (this is MachO).finalize() {
  for (reloc : this.binary.relocs)
    this.preprocess_symbol(reloc, reloc.target);
  this.calculate_layout();
  for (reloc : this.binary.relocs)
    this.process_relocation(reloc);
}

/*
 * struct mach_header {
 *   uint32_t magic;
 *   cpu_type_t cputype;
 *   cpu_subtype_t cpusubtype;
 *   uint32_t filetype;
 *   uint32_t ncmds;
 *   uint32_t sizeofcmds;
 *   uint32_t flags;
 * }
 */
def (this is MachO).encode_mach_header(out) {
  def info := this.layout.info(MachO.header_name);
  assert_equal(info.start, out.length);
  out.write_int32(16rFEEDFACE);
  out.write_int32(7); // CPU_TYPE_X86
  out.write_int32(3); // cpusubtype
  out.write_int32(1); // MH_OBJECT
  out.write_int32(this.ncmds);
  def start_info := this.layout.info(MachO.commands_start_marker);
  def end_info := this.layout.info(MachO.commands_end_marker);
  def sizeofcmds := end_info.end - start_info.start;
  out.write_int32(sizeofcmds);
  out.write_int32(5);
  assert_equal(info.end, out.length);  
}

def MachO.header_size -> 7 * WORD_SIZE;

def (this is MachO).encode(out) {
  this.encode_mach_header(out);
  this.encode_load_commands(out);
  this.encode_sections(out);
}

def (this is MachO).encode_load_commands(out) {
  this.encode_segment_command(out);
  this.encode_section_headers(out);
  this.encode_symtab_command(out);
  this.encode_dysymtab_command(out);
}

def MachO.commands_start_marker -> "COMMANDS{";

def MachO.commands_end_marker -> "COMMANDS}";

def MachO.segments_start_marker -> "SEGMENTS{";

def MachO.segments_end_marker -> "SEGMENTS}";

def (this is MachO).calculate_layout() {
  def layout := this.layout;
  // Add the mach header
  layout.add_section(MachO.header_name, null, MachO.header_size,
      WORD_SIZE);
  // Add segment load command with section headers
  layout.next_section(MachO.commands_start_marker, 0, 1);
  layout.next_section(MachO.segment_command_name,
      MachO.sizeof_segment_command, WORD_SIZE);
  for (section : this.sections) {
    layout.next_section(section.header_name,
        MachO.section_header_size, WORD_SIZE);
  }
  // Add remaining load commands
  layout.next_section(MachO.symtab_command_name,
      MachO.sizeof_symtab_command, WORD_SIZE);
  layout.next_section(MachO.dysymtab_command_name,
      MachO.sizeof_dysymtab_command, WORD_SIZE);
  layout.next_section(MachO.commands_end_marker, 0, 1);
  // Add sections
  layout.next_section(MachO.segments_start_marker, 0, 1);
  for (section : this.all_sections) {
    def name := section.name;
    def alignment := 1 << section.align;
    layout.next_section(section.name, section.size, alignment);
  }
  // Make sure the layout is padded to word size, independent of the
  // alignment of the last section.
  layout.next_section(MachO.segments_end_marker, 0, WORD_SIZE);
  layout.calculate();
  layout.dump();
}

protocol RelocationTableEntry;

def RelocationTableEntry.new(offset, is_relative) -> new RelocationTableEntry {
  offset := offset,
  is_relative := is_relative
}

def (this is RelocationTableEntry).encode(out) {
  out.write_int32(this.offset);
  def symbolnum := 2;
  def pcrel := if this.is_relative then 1 else 0;
  def length := 2;
  def extern := 0;
  def type := 0;
  out.write_int32((type << 28) | (extern << 27) | (length << 25) | (pcrel << 24) | symbolnum);
}

def RelocationTableEntry.size -> 2 * WORD_SIZE;

protocol RelocationTable;

def RelocationTable.new() -> new RelocationTable {
  entries := new ArrayList()
}

def (this is RelocationTable).name -> "#RELOCATION";

def (this is RelocationTable).align -> WORD_ALIGN;

def (this is RelocationTable).add_entry(offset, is_relative) {
  this.entries.add(new RelocationTableEntry(offset, is_relative));
}

def (this is RelocationTable).encode(out, macho) {
  for (entry : this.entries)
    entry.encode(out);
}

def (this is RelocationTable).count
 -> this.entries.length;

def (this is RelocationTable).size
 -> this.entries.length * RelocationTableEntry.size;

protocol MachOSection;

protocol JumpTable is MachOSection;

def (this is MachOSection).header_name -> "${this.name}.header";

def (this is MachOSection).name -> "${this.segname}.${this.sectname}";

def JumpTable.new() -> new JumpTable {
  rCount := new Ref(0)
}

def (this is JumpTable).count -> this.rCount.get();

def (this is JumpTable).add_extern() -> this.rCount.set(this.count + 1);

def (this is JumpTable).size -> 5 * this.count;

def (this is JumpTable).segname -> "__IMPORT";

def (this is JumpTable).sectname -> "__jump_table";

def (this is JumpTable).flags -> 16r84000408;

def (this is JumpTable).reserved2 -> 5;

def (this is JumpTable).align -> 0;

def (this is JumpTable).nreloc -> 0;

def (this is JumpTable).encode(out, macho) {
  for (i : 0 .. this.size)
    out.write_int8(16rF4); // HLT
}

protocol TextSection is MachOSection;

def TextSection.new(reloc_table) -> new TextSection {
  reloc_table := reloc_table,
  blocks := new ArrayList(),
  index := new HashMap(),
  rLength := new Ref(0),
  rNreloc := new Ref(0),
  code := new BlobStream()
}

def (this is TextSection).length -> this.rLength.get();

def (this is TextSection).nreloc -> this.reloc_table.count;

def (this is TextSection).length:=(value) -> this.rLength.set(value);

def (this is TextSection).segname -> "__TEXT";

def (this is TextSection).sectname -> "__text";

def (this is TextSection).flags -> 16r80000400;

def (this is TextSection).reserved2 -> 0;

def (this is TextSection).align -> WORD_ALIGN;

def (this is TextSection).add_block(name, code) {
  this.blocks.add(new { name := name, code := code });
  this.code.write_data(code);
  def result := this.length;
  this.index[name] := result;
  this.length := this.length + code.length;
  result;
}

def (this is TextSection).code_block_offset(name) {
  ref offset := 0;
  with_1cc (return) {
    for (block : this.blocks) {
      if block.name = name then {
        return(offset);
      } else {
        offset := offset + block.code.length;
      }
    }
    fail("Code block '${name}' not found");
  }
}

def (this is TextSection).rewrite_int32(offset, value) {
  this.code.rewrite_int32(offset, value);
}

def (this is TextSection).size
 -> this.code.length;

def (this is TextSection).encode(out, macho) {
  out.write_data(this.code.get_blob());
}

// A c_string section.  Strings in this section end up in the address
// space of the running program.
protocol CStringSection is MachOSection;

def CStringSection.new() -> new CStringSection {
  order := new ArrayList(),
  strings := new HashMap(),
  r_length := new Ref(0)
}

def (this is CStringSection).length -> this.r_length.get();

def (this is CStringSection).nreloc -> 0;

def (this is CStringSection).length:=(value) -> this.r_length.set(value);

def (this is CStringSection).segname -> "__TEXT";

def (this is CStringSection).sectname -> "__cstring";

def (this is CStringSection).flags -> 16r00000002;

def (this is CStringSection).reserved2 -> 0;

def (this is CStringSection).align -> 0;

def (this is CStringSection)[str] -> this.strings[str];

def (this is CStringSection).size -> this.length;

def (this is CStringSection).ensure(str) {
  def prev := this.strings[str];
  if prev = null then {
    def offset := this.length;
    this.order.add(str);
    this.strings[str] := offset;
    this.length := offset + str.length + 1;
    offset;
  } else {
    prev;
  }
}

def (this is CStringSection).encode(out, macho) {
  for (str : this.order)
    out.write_c_string(str);
}

/*
 * This string table is only seen by the linker and loader, the
 * strings here are not loaded into the address space of the program.
 */
protocol StringTable;

def StringTable.new() {
  def result := new StringTable {
    string_map := new HashMap(),
    strings := new ArrayList(),
    r_cursor := new Ref(0)
  }
  result.ensure("");
  result;
}

def (this is StringTable).cursor -> this.r_cursor.get();

def (this is StringTable).cursor:=(value) -> this.r_cursor.set(value);

def (this is StringTable).ensure(name) {
  def prev := this.string_map[name];
  if prev = null then {
    def result := this.cursor;
    this.cursor := this.cursor + name.length + 1;
    this.strings.add(name);
    this.string_map[name] := result;
    result;
  } else {
    prev;
  }
}

def (this is StringTable)[name] -> this.string_map[name];

def (this is StringTable).encode(out, macho) {
  for (str : this.strings)
    out.write_c_string(str);
}

def (this is StringTable).size {
  ref result := 0;
  for (str : this.strings)
    result := result + str.length + 1;
  result;
}

def (this is StringTable).name -> "#STRINGS";

def (this is StringTable).align -> 0;

def (this is StringTable).length -> this.strings.length;

protocol IndirectSymbols;

def IndirectSymbols.new() -> new IndirectSymbols { rCount := new Ref(0) };

def (this is IndirectSymbols).name -> "#INDIRECT";

def (this is IndirectSymbols).align -> WORD_ALIGN;

def (this is IndirectSymbols).count -> this.rCount.get();

def (this is IndirectSymbols).add() -> this.rCount.set(this.count + 1);

def (this is IndirectSymbols).encode(out, macho) {
  for (i : 0 .. this.count)
    out.write_int32(i);
}

def (this is IndirectSymbols).size -> WORD_SIZE * this.count;

protocol SymbolTable;

def SymbolTable.new(strings) -> new SymbolTable {
  strings := strings,
  locals := new ArrayList(),
  externs := new ArrayList()
}

def (this is SymbolTable).add_local(name) {
  // Ensure that the string table contains this name.
  this.strings.ensure(name);
  this.locals.add(new Symbol(name));
}

def (this is SymbolTable).add_extern(name_index, jump_offset) {
  this.externs.add(new Symbol(name_index, jump_offset));
}

def (this is SymbolTable).local_count -> this.locals.length;

def (this is SymbolTable).external_count -> this.externs.length;

def (this is SymbolTable).name -> "#SYMBOLS";

def (this is SymbolTable).align -> WORD_ALIGN;

def (this is SymbolTable).length -> this.symbols.length;

def (this is SymbolTable).symbols -> this.locals + this.externs;

def (this is SymbolTable).encode(out, macho) {
  for (symbol : this.externs)
    symbol.encode_extern(out, macho);
  for (symbol : this.locals)
    symbol.encode_local(out, macho);
}

def (this is SymbolTable).size -> this.length * Symbol.size;

protocol Symbol;

def Symbol.new(name, start) -> new Symbol { name := name, start := start };

def Symbol.new(name) -> new Symbol { name := name };

def Symbol.size -> 3 * WORD_SIZE;

def (this is Symbol).encode_local(out, macho) {
  def name_index := macho.strings[this.name];
  out.write_int32(name_index);
  out.write_int8(16r0F);
  out.write_int8(16r01);
  out.write_int16(16r0000);
  def base := macho.offset_of(macho.text);
  def offset := macho.text.code_block_offset(this.name);
  out.write_int32(base + offset);
}

def (this is Symbol).encode_extern(out, macho) {
  out.write_int32(this.name);
  out.write_int8(16r01);
  out.write_int8(16r00);
  out.write_int16(16r0000);
  out.write_int32(0);
}

def MachO.header_name -> "mach_header";

def MachO.header_size -> 7 * WORD_SIZE;

def (this is MachO).nsects -> this.sections.length;

def (this is MachO).ncmds -> 3;

def MachO.sizeof_segment_command -> SEGMENT_COMMAND_SIZE;

def MachO.segment_command_name -> "LC_SEGMENT";

def MachO.section_header_size -> 17 * WORD_SIZE;

def (this is MachO).sizeof_segment_command -> SEGMENT_COMMAND_SIZE + (this.nsects * SECTION_HEADER_SIZE);

def MachO.symtab_command_name -> "LC_SYMTAB";

def MachO.sizeof_symtab_command -> 6 * WORD_SIZE;

def MachO.dysymtab_command_name -> "LC_DYSYMTAB";

def MachO.sizeof_dysymtab_command -> 20 * WORD_SIZE;

def SEGMENT_COMMAND_SIZE := 56;
def SECTION_HEADER_SIZE := 68;

def (this is MachO).encode_load_commands(out) {
  this.encode_segment_command(out);
  this.encode_section_headers(out);
  this.encode_symtab_command(out);
  this.encode_dysymtab_command(out);
}

def (this is MachO).encode_symtab_command(out) {
  def info := this.layout.info(MachO.symtab_command_name);
  assert_equal(info.start, out.length);
  out.write_int32(16r2); // LC_SYMTAB
  out.write_int32(info.size);
  def symbols_info := this.layout.info(this.symbols.name);
  out.write_int32(this.offset_of(this.symbols));
  out.write_int32(this.symbols.length);
  out.write_int32(this.offset_of(this.strings));
  out.write_int32(this.strings.size);
  assert_equal(info.end, out.length);
}

def (this is MachO).encode_dysymtab_command(out) {
  def info := this.layout.info(MachO.dysymtab_command_name);
  assert_equal(info.start, out.length);
  out.write_int32(16rB); // LC_DYSYMTAB
  out.write_int32(MachO.sizeof_dysymtab_command);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(this.symbols.external_count);
  out.write_int32(this.symbols.local_count);
  out.write_int32(0);
  out.write_int32(this.symbols.external_count);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(this.offset_of(this.indirect_symbols));
  out.write_int32(this.symbols.external_count);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  out.write_int32(0);
  assert_equal(info.end, out.length);
}

/*
 * struct segment_command {
 *   uint32_t cmd;
 *   uint32_t cmdsize;
 *   char segname[16];
 *   uint32_t vmaddr;
 *   uint32_t vmsize;
 *   uint32_t fileoff;
 *   uint32_t filesize;
 *   vm_prot_t maxprot;
 *   vm_prot_t initprot;
 *   uint32_t nsects;
 *   uint32_t flags;
 * }
 */
def (this is MachO).encode_segment_command(out) {
  def layout := this.layout;
  def info := layout.info(MachO.segment_command_name);
  assert_equal(info.start, out.length);
  out.write_int32(16r01); // LC_SEGMENT
  out.write_int32(this.sizeof_segment_command);
  out.write_c_string("", 16);
  def segments_start_info := layout.info(MachO.segments_start_marker);
  def segments_end_info := layout.info(MachO.segments_end_marker);
  def size := segments_start_info.start - segments_end_info.end;
  out.write_int32(0);
  out.write_int32(size);
  out.write_int32(segments_start_info.start);
  out.write_int32(size);
  out.write_int32(7);
  out.write_int32(5);
  out.write_int32(this.nsects);
  out.write_int32(0); // flags
  assert_equal(info.end, out.length);
}

/*
 * struct section {
 *   char sectname[16];
 *   char segname[16];
 *   uint32_t addr;
 *   uint32_t size;
 *   uint32_t offset;
 *   uint32_t align;
 *   uint32_t reloff;
 *   uint32_t nreloc;
 *   uint32_t flags;
 *   uint32_t reserved1;
 *   uint32_t reserved2;
 * }
 */
def (this is MachO).encode_section_headers(out) {
  for (section : this.sections) {
    def header_info := this.layout.info(section.header_name);
    def section_info := this.layout.info(section.name);
    assert_equal(header_info.start, out.length);
    out.write_c_string(section.sectname, 16);
    out.write_c_string(section.segname, 16);
    out.write_int32(section_info.start);
    out.write_int32(section_info.size);
    out.write_int32(section_info.start);
    out.write_int32(section.align);
    if section.nreloc = 0 then
      out.write_int32(0);
    else
      out.write_int32(this.offset_of(this.reloc_table));
    out.write_int32(section.nreloc);
    out.write_int32(section.flags);
    out.write_int32(0);
    out.write_int32(section.reserved2);
    assert_equal(header_info.end, out.length);
  }
}

def (this is MachO).all_sections -> this.sections + this.dark_sections;

def (this is MachO).encode_sections(out) {
  for (section : this.all_sections) {
    def info := this.layout.info(section.name);
    assert_true(out.length <= info.start);
    out.pad_to(info.start);
    section.encode(out, this);
    assert_true(out.length <= info.end);
    out.pad_to(info.end);
  }
}

def (this is MachO).address_of(target) {
  // The address of a section is just its location within this file
  // (all sections are mapped to corresponding locations) but starting
  // from the beginning of the segments part, not the beginning of the
  // file.
  def sections_info := this.layout.info(MachO.segments_start_marker);
  this.offset_of(target) - sections_info.start;
}

def (this is MachO).offset_of(target)
 -> this.layout.info(target.name).start;

def (this is MachO).ncmds {
  ref result := 0;
  for (element : this.elements)
    result := result + element.load_command_count;
  result;
}

def (this is MachO).preprocess_symbol(relocation, symbol) -> null;

def (this is MachO).preprocess_symbol(relocation, symbol is DylibSymbol) {
  def name := symbol.name;
  def index := this.dysym_indices[name];
  if index = null then {
    def new_index := this.dysym_indices.size;
    this.dysym_indices[name] := new_index;
    def name_index := this.strings.ensure(name);
    this.jump_table.add_extern();
    this.indirect_symbols.add();
    this.symbols.add_extern(name_index, 0);
  }
  def source_offset := this.text.code_block_offset(relocation.assm.name);
  this.reloc_table.add_entry(source_offset + relocation.offset,
      relocation.is_relative);
}

def (this is MachO).preprocess_symbol(relocation, symbol is StringSymbol) {
  def source_offset := this.text.code_block_offset(relocation.assm.name);
  this.reloc_table.add_entry(source_offset + relocation.offset,
      false);
  this.cstrings.ensure(symbol.value);
}

def (this is MachO).symbol_address(target is DylibSymbol) {
  def jump_table_address := this.address_of(this.jump_table);
  def index := this.dysym_indices[target.name];
  jump_table_address + (5 * index);  
}

def (this is MachO).symbol_address(target is LocalSymbol)
 -> this.text.code_block_offset(target.name);

def (this is MachO).symbol_address(target is StringSymbol)
 -> this.offset_of(this.cstrings) + this.cstrings[target.value];

def (this is MachO).process_relocation(relocation) {
  def target_offset := this.symbol_address(relocation.target);
  def source_offset := this.text.code_block_offset(relocation.assm.name);
  def instr_offset := source_offset + relocation.offset;
  if relocation.is_relative then {
    this.text.rewrite_int32(instr_offset, target_offset - (instr_offset + 4));
  } else {
    this.text.rewrite_int32(instr_offset, target_offset);
  }
}
