protocol ArrayList is Sequence;

def ArrayList.new() -> new ArrayList(0);

def ArrayList.new(size is Integer) -> new ArrayList {
  contents_ := new Ref(new MutablePrimitiveArray(size)),
  length_ := new Ref(size)
}

def ArrayList.new(elms is PrimitiveArray) {
  def result := new ArrayList(elms.length);
  for (i : 0 .. elms.length)
    result[i] := elms[i];
  result;
}

def ArrayList.new(seq is Sequence) {
  def result := new ArrayList(0);
  for (elm : seq)
    result.add(elm);
  result;
}

def (this is ArrayList)[i] -> this.contents[i];

def (this is ArrayList).length -> this.length_.get();

def (this is ArrayList).contents -> this.contents_.get();

def (this is ArrayList)[i]:=(value) -> this.contents[i] := value;

def (this is ArrayList).to_string() {
  def out := new StringStream();
  out.add("[");
  ref first := true;
  for (el : this) {
    if first then first := false;
    else out.add(", ");
    out.add(el);
  }
  out.add("]");
  out.to_string();
}

def (this is ArrayList)=(that is ArrayList) {
  if this.length != that.length then {
    false;
  } else {
    with_1cc (return) {
      for (i : 0 .. this.length) {
        if this[i] != that[i] then
          return(false);
      }
      true;
    }
  }   
}

def (this is ArrayList)+(that is ArrayList) {
  def result := new ArrayList(this.length + that.length);
  for (i : 0 .. this.length)
    result[i] := this[i];
  for (i : 0 .. that.length)
    result[this.length + i] := that[i];
  result;
}

def (this is ArrayList).add(value) {
  def new_length := this.length + 1;
  this.ensure_capacity(new_length);
  this.contents[this.length] := value;
  this.length_.set(new_length);
  value;
}

def (this is ArrayList).ensure_capacity(capacity) {
  def old_contents := this.contents;
  if not capacity < old_contents.length then {
    def new_contents := new MutablePrimitiveArray(capacity * 2);
    for (i : 0 .. this.length)
      new_contents[i] := old_contents[i];
    this.contents_.set(new_contents);
  }
}

def (this is ArrayList).iter {
  def self := this;
  def index_itr := (0 .. self.length).iter;
  new Iter {
    has_next -> index_itr.has_next,
    next -> self[index_itr.next]
  }
}
